<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Extreme WebGPU Stress (Debugged & Boosted)</title>
<style>
html,body{margin:0;background:#000;overflow:hidden;height:100%}
canvas{display:block;width:100%;height:100%}
#i{position:fixed;left:10px;top:10px;color:#0f0;font:14px monospace;background:rgba(0,0,0,0.7);padding:5px;pointer-events:none;z-index:999}
</style>
</head>
<body>
<div id="i">Initializing Extreme WebGPU Stress...</div>
<canvas id="c"></canvas>
<script type="module">
const canvas = document.getElementById('c');
const info = document.getElementById('i');

// 1. High DPI Support (Increases load by 4x on retina screens)
const dpr = window.devicePixelRatio || 1;
canvas.width = innerWidth * dpr;
canvas.height = innerHeight * dpr;

if(!('gpu' in navigator)){
  info.textContent='WebGPU not supported in this browser.';
  info.style.color = 'red';
  throw new Error('WebGPU not supported');
}

const adapter = await navigator.gpu.requestAdapter({powerPreference:'high-performance'});
if (!adapter) {
    info.textContent = 'No suitable GPU adapter found.';
    throw new Error('No adapter');
}
const device  = await adapter.requestDevice();
const ctx = canvas.getContext('webgpu');
const format = navigator.gpu.getPreferredCanvasFormat();
ctx.configure({device, format, alphaMode:'opaque'});

// متغیرهای استرس
let steps = 900; 
let scale = 1.0; 

// هندل کردن ریسایز برای جلوگیری از استرچ شدن
window.addEventListener('resize', () => {
    canvas.width = innerWidth * dpr;
    canvas.height = innerHeight * dpr;
    // با ریسایز کانتکست باید دوباره کانفیگ شود اما در WebGPU مدرن معمولا خودکار هندل میشود 
    // یا با تغییر سایز بافر در فریم بعدی درست میشود.
});

const shaderCode = `
struct U { r:vec2<f32>, t:f32, steps:u32 }
@group(0) @binding(0) var<uniform> u:U;

fn hash(p:vec3<f32>) -> f32 {
  return fract(sin(dot(p, vec3<f32>(17.1, 31.7, 47.2))) * 43758.5453);
}

fn noise(p:vec3<f32>) -> f32 {
  let i = floor(p);
  let f = fract(p);
  let w = f * f * (3.0 - 2.0 * f);
  
  let n00 = mix(hash(i + vec3(0,0,0)), hash(i + vec3(1,0,0)), w.x);
  let n10 = mix(hash(i + vec3(0,1,0)), hash(i + vec3(1,1,0)), w.x);
  let n01 = mix(hash(i + vec3(0,0,1)), hash(i + vec3(1,0,1)), w.x);
  let n11 = mix(hash(i + vec3(0,1,1)), hash(i + vec3(1,1,1)), w.x);
  
  return mix(mix(n00, n10, w.y), mix(n01, n11, w.y), w.z);
}

// Increased Octaves from 9 to 12 for more heavy math
fn fbm(p:vec3<f32>) -> f32 {
  var a = 0.5;
  var s = 0.0;
  var q = p;
  // Increased loop iteration for stress
  for(var i=0; i<12; i++){ 
      s += a * noise(q); 
      q *= 2.02; // Slightly changed to avoid artifacts
      a *= 0.5; 
  }
  return s;
}

// Domain Warping: Makes it 3x heavier per step
fn map(p:vec3<f32>) -> f32 {
    let q = vec3<f32>(
        fbm(p + vec3(0.0, 0.0, 0.0)),
        fbm(p + vec3(5.2, 1.3, 2.8)),
        fbm(p - vec3(1.2, 2.5, 4.1))
    );
    // Extreme composition
    return fbm(p + 4.0 * q + vec3(0, u.t * 0.2, 0)) - 0.45;
}

@fragment fn fs(@builtin(position) pos:vec4<f32>) -> @location(0) vec4<f32> {
  // Correct aspect ratio calculation
  let uv = (pos.xy - 0.5 * u.r) / u.r.y;
  
  var ro = vec3<f32>(0.0, 0.0, 3.5);
  let rd = normalize(vec3<f32>(uv, -1.5));
  
  var d = 0.0;
  var acc = 0.0;
  
  // The Heavy Loop
  for(var i:u32 = 0u; i < u.steps; i++) {
    let p = ro + rd * d;
    
    // Use the heavy map function
    let h = map(p);
    
    // More complex accumulation math
    let dens = exp(-abs(h) * 9.0);
    acc += dens * 0.015;
    
    d += 0.012; // Smaller step size = more samples usually needed
    
    // Optimization break to save GPU from TDR (Time detection recovery) if too far
    if(d > 20.0) { break; }
  }
  
  // Heat coloring
  let col = vec3(acc, acc * 0.6, acc * 0.2) + vec3(0.1, 0.1, 0.2) * (d*0.1);
  return vec4<f32>(col, 1.0);
}

@vertex fn vs(@builtin(vertex_index) i:u32) -> @builtin(position) vec4<f32> {
  var p = array<vec2<f32>,3>(vec2(-1.0, -1.0), vec2(3.0, -1.0), vec2(-1.0, 3.0));
  return vec4(p[i], 0.0, 1.0);
}
`;

const shader = device.createShaderModule({code: shaderCode});

const pipeline = device.createRenderPipeline({
  layout:'auto',
  vertex:{module:shader, entryPoint:'vs'},
  fragment:{module:shader, entryPoint:'fs', targets:[{format}]}
});

// Fix: Using ArrayBuffer to mix Float32 and Uint32 correctly
const uniformBufferSize = 16; // 4 * 4 bytes
const ubuf = device.createBuffer({
    size: uniformBufferSize, 
    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
});

const bind = device.createBindGroup({
    layout: pipeline.getBindGroupLayout(0),
    entries: [{binding: 0, resource: {buffer: ubuf}}]
});

// Data Views for mixing types
const cpuBuffer = new ArrayBuffer(uniformBufferSize);
const floatView = new Float32Array(cpuBuffer);
const uintView = new Uint32Array(cpuBuffer);

let t0 = performance.now();
let frameCount = 0;

function frame(){
  const now = performance.now();
  const t = (now - t0) / 1000;
  
  // Ramping up stress
  // Increased max steps to 3000 (was 1500)
  steps = Math.min(3000, steps + 2); 
  
  // Scale parameter logic
  scale = Math.min(2.0, scale + 0.001);

  // Update Info
  if(frameCount % 30 === 0) {
      info.textContent = `WebGPU Extreme Stress | Time: ${t.toFixed(1)}s | Steps: ${steps} | Res: ${canvas.width}x${canvas.height}`;
  }
  frameCount++;

  // Correctly packing data
  floatView[0] = canvas.width;  // r.x
  floatView[1] = canvas.height; // r.y
  floatView[2] = t;             // t
  uintView[3]  = steps;         // steps (uint32)

  device.queue.writeBuffer(ubuf, 0, cpuBuffer);

  const enc = device.createCommandEncoder();
  const pass = enc.beginRenderPass({
    colorAttachments:[{
        view: ctx.getCurrentTexture().createView(),
        clearValue: {r:0, g:0, b:0, a:1}, 
        loadOp: 'clear', 
        storeOp: 'store'
    }]
  });
  
  pass.setPipeline(pipeline);
  pass.setBindGroup(0, bind);
  pass.draw(3);
  pass.end();
  
  device.queue.submit([enc.finish()]);
  requestAnimationFrame(frame);
}

frame();

addEventListener('keydown', e => { 
    if(e.key === 'Escape') location.reload(); 
});
</script>
</body>
</html>
